import discord
from discord.ext.commands import Bot
from character import Character
from battle import Battle
from player import Player
from exceptions import AlreadyInBattleException
from configparser import RawConfigParser

config = RawConfigParser()
with open("config.ini") as f:
    config.read_file(f)
    TOKEN = config.get("bot", "token")
    print(TOKEN)


# 'Create dictionaries to keep track of players between guilds players follows the organization:
# "players" is a dictionary with keys generated using the guild id cast to a string and values of dictionaries
# whose keys are the author returned by discord.Message.author and whose values are Player objects
# "battles" is a dictionary with keys generated by concatenated the name of the battle with guild id (as a string).
# the values of "battles" are Battle objects
client = Bot(command_prefix=("!", "?"))
players = {}
battles = {}


def get_player(ctx):
    guild_id_string = str(ctx.message.channel.guild.id)
    return players[guild_id_string][ctx.message.author]


@client.event
async def on_ready():
    print("logged in")


@client.command(pass_context=True)
async def start_battle(ctx):
    battle = get_player(ctx).character.get_battle()
    if battle is None:
        await ctx.message.channel.send("character is not currently in battle")
        return
    battle.start()
    await ctx.message.channel.send("Battle started successfully!")
    await ctx.message.channel.send("It is currently {}'s turn".format(battle.get_turn().get_name()))


@client.command(pass_context=True)
async def leave_battle(ctx):
    player = get_player(ctx)
    await player.leave_battle(player.character.get_battle())


@client.command(pass_context=True)
async def join_battle(ctx):
    name = " ".join(ctx.message.content.split()[1:])
    if len(name) == 0:
        await ctx.message.channel.send("Please enter a battle name")
        return
    if battles[name + str(ctx.message.channel.guild.id)] is None:
        await ctx.message.channel.send("No battle found with name \"{}\"".format(name))
        return
    try:
        await get_player(ctx).join_battle(battles[name + str(ctx.message.channel.guild.id)])
        await ctx.message.channel.send("Joined battle successfully".format(name))
    except AlreadyInBattleException:
        await ctx.message.channel.send("Player is already in battle")


@client.command(pass_context=True)
async def create_battle(ctx):
    name = " ".join(ctx.message.content.split()[1:])
    if len(name) == 0:
        await ctx.message.channel.send("Please enter a name")
        return
    try:
        player = get_player(ctx)
        if not player.in_battle():
            battle = Battle(name)
            await player.join_battle(battle)
            battles[battle.get_name() + str(ctx.message.channel.guild.id)] = battle
            await ctx.message.channel.send("battle \"{}\" created successfully".format(name))
        else:
            await ctx.message.channel.send("You are currently in a battle. Please finish current battle or "
                                           "enter !leave_battle to continue")
    except KeyError as e:
        await ctx.message.channel.send("No character exists for {}".format(ctx.message.author))


@client.command(pass_context=True)
async def create_character(ctx):
    guild_id_string = str(ctx.message.channel.guild.id)
    if guild_id_string not in players.keys():
        players[guild_id_string] = {}

    name = " ".join(ctx.message.content.split()[1:])
    if len(name) == 0:
        await ctx.message.channel.send("ERROR: Please enter a name")
        return
    players[guild_id_string] = {}
    players[guild_id_string][ctx.message.author] = Player(Character(name), ctx.message.author)
    await ctx.message.channel.send("character \"{}\" created successfully".format(name))


@client.command(pass_context=True)
async def stats(ctx):
    battle = get_player(ctx).character.get_battle()
    if battle is None:
        await ctx.message.channel.send("character is not in a battle")
        return
    await ctx.message.channel.send(await battle.get_stats())


@client.command(pass_context=True)
async def hit(ctx):
    name = " ".join(ctx.message.content.split()[1:])
    if len(name) == 0:
        await ctx.message.channel.send("Please enter the name of the character")
        return
    character = get_player(ctx).character
    battle = character.get_battle()
    turn = battle.get_turn()

    if not await battle.has_character(name):
        await ctx.message.channel.send("Character is not in the current battle")
        return
    if not get_player(ctx).in_battle():
        await ctx.message.channel.send("Your character is not currently in a battle. "
                                       "Try !join_battle <battle name> to join a battle")
        return
    if turn is not get_player(ctx).character:
        await ctx.message.channel.send("It is not currently your turn")
        return

    other = await battle.get_character(name)
    result = await character.attack(other, character.hit)
    await ctx.message.channel.send(result)
    battle.next_turn()
    await ctx.message.channel.send("it is now {}'s turn".format(battle.get_turn().get_name()))

client.run(TOKEN)
